---
layout:     post
title:      OS_Labs exps of ucore
subtitle:   基于Ucore操作系统实验😅
date:       2018-07-01
author:     IdiotLeo
header-img: img/beach_real_2.jpg
catalog: true
tags:
    - Operating System
    - Ucore
---

>Notes:本文仅为IdiotLeo学习ucore时遇到的关键问题的记录。

# OS_Ucore

THU OS Labs based on Ucore!

陈渝老师维护的github[网址](https://github.com/chyyuu/os_course_info)

详细的操作系统实验[指导手册](https://chyyuu.gitbooks.io/ucore_os_docs/content/)

### Lab 0 : 实验准备以及环境搭建


##### 了解OS实验


我们准备如何一步一步来实现ucore呢？根据一个操作系统的设计实现过程，我们可以有如下的实验步骤：

1、启动操作系统的bootloader，用于了解操作系统启动前的状态和要做的准备工作，了解运行操作系统的硬件支持，操作系统如何加载到内存中，理解两类中断--“外设中断”，“陷阱中断”等；

2、物理内存管理子系统，用于理解x86分段/分页模式，了解操作系统如何管理物理内存；

3、虚拟内存管理子系统，通过页表机制和换入换出（swap）机制，以及中断-“故障中断”、缺页故障处理等，实现基于页的内存替换算法；

4、内核线程子系统，用于了解如何创建相对与用户进程更加简单的内核态线程，如果对内核线程进行动态管理等；

5、用户进程管理子系统，用于了解用户态进程创建、执行、切换和结束的动态管理过程，了解在用户态通过系统调用得到内核态的内核服务的过程；

6、处理器调度子系统，用于理解操作系统的调度过程和调度算法；

7、同步互斥与进程间通信子系统，了解进程间如何进行信息交换和共享，并了解同步互斥的具体实现以及对系统性能的影响，研究死锁产生的原因，以及如何避免死锁；

8、文件系统，了解文件系统的具体实现，与进程管理等的关系，了解缓存对操作系统IO访问的性能改进，了解虚拟文件系统（VFS）、buffer cache和disk driver之间的关系。

其中每个开发步骤都是建立在上一个步骤之上的，就像搭积木，从一个一个小木块，最终搭出来一个小房子。在搭房子的过程中，完成从理解操作系统原理到实践操作系统设计与实现的探索过程。

![](http://ow7qvf5zp.bkt.clouddn.com/image001.png)


##### 实验环境

<strong>virtualbox</strong> + <strong>配置好的ubuntu x64</strong>[映像云盘地址](https://pan.baidu.com/s/11zjRK) 

下载代码
` $ git clone https://github.com/chyyuu/ucore_lab.git `

##### 开发调试的基本工具

<strong>
    gcc
    AT&T汇编基本语法
</strong>

<strong>gcc基本用法</strong>：

`$ gcc -Wall hello.c -o hello`

hello.c为文件名，hello为可执行文件名。
注：选项 -Wall 开启编译器几乎所有常用的警告──强烈建议你始终使用该选项。编译器有很多其他的警告选项，但 -Wall 是最常用的。默认情况下GCC 不会产生任何警告信息。当编写 C 或 C++ 程序时编译器警告非常有助于检测程序存在的问题。

`$ ./hello
Hello, world!`

<strong>AT&T汇编基本语法</strong>：

![](http://ow7qvf5zp.bkt.clouddn.com/WT0EH%5DM5TY7Z6%603HWA5MS~L.png)
![](http://ow7qvf5zp.bkt.clouddn.com/M530V@PV%25~Y$2%25__YN%7DD42H.png)

### Lab 1 : 系统软件启动过程

##### 练习1：理解通过make生成执行文件的过程

一、操作系统ucore的ucore.img怎么i步步生成的

make qemu

首先在Ubuntu里面运行lab1_result，我们可以看到在启动操作系统之前，电脑对一系列文件进行了编译，通过make qemu我们可以看到，电脑首先针对kern文件下的.c和.S文件进行了编译，然后通过ld把kern文档下的所有程序和bin文件连接起来，并重定位他们的数据，然后生成kernel程序。

其次电脑针对boot文件夹下面的.c和.S文件进行了编译，并且将tools文件夹下面的sign.c也进行了编译，然后通过ld生成bootblock程序。

因此通过make qemu我们可以了解到在生成ucore.img之前，需要先通过编译链接，生成kernel和bootblock的ELF文件。

接下来我们可以看到通过dd指令，将上面我们生成的kernel和bootblock的ELF文件拷贝到ucore.img当中，根据拷贝的顺序我们可以看到，首先是将bootblock拷贝进了ucore.img，然后才是将kernel拷贝进ucore.img，所以可以得出bootblock是引导区，kernel是操作系统内核。

除此之外，在上文我们看到电脑还对sign.c进行了编译，然而在接下来的链接中并没有对其进行进一步操作，所以我们打开sign.c文件进行查看。

在这里我们看到给sign.c传进去了3个参数，其中通过输出，我们可以了解到argv[1]传入的是obj/bootblock.out：

紧接着在下面定义了一个长度为512的字符串，然后从obj/bootblock.out中读取500个字符存到buf里面，接下来在buf的结尾加上0x55AA，并且将其写到argv[2]里面，由于在运行中看不出来argv[2]是哪里，所以针对sign.c文件进行了修改，输出了argv[2]：

可以看到我们将更改后的buf存入了bin/bootblock当中，即我们的sign.c文件，在引导区内做了个0x55AA的标记，然后将其存入了bin/bootblock当中，然后拷贝到ucore.img里面。

自此，我们的ucore.img文件正式生成。 

二、一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？

- 磁盘主引导扇区只有512字节 
- 磁盘最后两个字节为0x55AA 
- 由不超过466字节的启动代码和不超过64字节的硬盘分区表加上两个字节的结束符组成

##### 练习2：使用qemu执行并调试lab1中的软件

改gdbinit（去掉continue就用continue调试，否则用next调试）

GDB中设置断点：b* 地址

continue单步调试

反汇编：x/01i $pc（获得当前位置附近的反汇编代码）

##### 练习3：分析bootloader进入保护模式的过程

一、为何开启A20

8088/8086只有20位地址线，按理它的寻址空间是2^20，应该是1024KB，但PC机的寻址结构是segment:offset，segment和offset都是16位的寄存器，最大值是0ffffh，换算成物理地址的计算方法是把segment左移4位，再加上offset，所以segment:offset所能表达的寻址空间最大应为0ffff0h + 0ffffh = 10ffefh（前面的0ffffh是segment=0ffffh并向左移动4位的结果，后面的0ffffh是可能的最大offset），这个计算出的10ffefh大约是1088KB，就是说，segment:offset的地址表达能力超过了20位地址线的物理寻址能力，所以当你访问大于1M区域是会发生回卷现象，如果你企图寻址100001h这个地址时，你实际得到的内容是地址00001h上的内容，而下一代的基于Intel 80286 CPU的PC AT计算机系统提供了24根地址线，这样CPU的寻址范围变为 2^24=16M,同时也提供了保护模式，可以访问到1MB以上的内存了，此时如果遇到“寻址超过1MB”的情况，系统不会再“回卷”了，这就造成了向下不兼容，为了保持完全的向下兼容性，IBM决定在PC AT计算机系统上加个硬件逻辑，来模仿以上的回绕特征，PC机在设计上在第21条地址线（也就是A20，原先20条地址线是A0-A19）上做了一个开关，当这个开关打开时，这条地址线和其它地址线一样可以使用，当这个开关关闭时，第21条地址线（A20）恒为0，这个开关就叫做A20 Gate。

在实模式下, 由于我们访问了高端内存区（1088K比1M多的部分），所以我们打开A20gate，在保护模式下，由于使用32位地址线，我们也是打开A20gate，目的是为了访问更大的内存区域。

二、如何初始化GDT表

接下来我们需要了解下GDT表（全局描述符表），在整个操作系统中我们只有一张GDT表，GDT可以放在内存的任意位置，但是CPU必须知道GDT的入口，在Intel里面有一个专门的寄存器GDTR用来存放GDT的入口地址，程序员将GDT设定在内存的某个位置之后，可以通过LGDT指令将GDT的入口地址加载到该寄存器里面，以后CPU就可以通过GDTR来访问GDT了。

最后我们需要了解如何使能和进入保护模式，关于这一点我们需要了解一个寄存器CR0，首先我们来看下CR0寄存器的各个位代表什么：

三、如何使能和进入保护模式

在这里由于我们需要进入保护模式，所以暂时可以先不用管其他的位，只需关注最低位的PE即可，PE是启用保护位(protection enable)，当设置该位的时候即开启了保护模式，系统上电复位的时候该位默认为0，于是便是实模式；当PE置1的时候，进入保护模式，实质上是开启了段级保护，只是进行了分段，没有开启分页机制，如果要开启分页机制的话我们需要同时置位PE和PG。

有了初步了解之后我们便知道的开启保护模式的相关操作，首先开启A20 Gate，其次加载全局描述符表GDT，最后只需要将CR0寄存器的最低位置为1即可。

接下来我们通过观察代码来查看UCore具体是[如何实现相应的操作的](https://blog.csdn.net/tiu2014/article/details/53998595)

首先是开启A20，根据上文我们知道需要将第20位为1即可，但是我们需要知道在UCore里是如何将A20置为1的。根据说明书我们可以知道，A20地址线由键盘控制器8042进行控制，我们的A20所对应的是8042里面的P21引脚，所以问题就变成了我们需要将P21引脚置1。

对于8042芯片来说，有两个端口地址60h和64h。对于这两个端口来说，0x64用来发送一个键盘控制命令，0x60用来传递参数，所以将P21引脚置1的操作就变成了，我们首先利用0x64输入一个写入的指令，然后由0x60读进去相应的参数来将P21置1。

由以下的资料我们可以知道，我们首先要先向64h发送0xd1的指令，然后向60h发送0xdf的指令。

在这里可能有人会有疑问，既然我们只需要将P21置为1就可以了，那么我们是不是可以传入多种不同的参数，只需要对应的位为1就好了，答案是不行的。我们传入的0xdf参数在这里也相当于一条指令，通过这条指令我们可以将A20的开关打开。

在这里我们还需要注意一个问题就是当前端口(60h或者64h)是否空闲，只有当这两个端口空闲的时候我们才可以向其传入数据，等待其空闲的代码为：

在这里testb $0x2, %al是用来检测64h端口是否为空闲，当输入缓存区为空，即我们可以向其传入数据时，64h端口中的状态寄存器的值为0x2，所以我们可以通过这条指令来等待64h端口空闲。在等到64h空闲之后我们会写入0xd1，表明我们要向60h里面写入数据。

然后我们需要加载GDT全局描述符。在代码里我们看到只用了一句指令便实现了加载GDT的操作：

我们首先追踪gdtdesc可以看到，它里面有两个参数，首先是word 0x17表示的是我们GDT表的大小，其次是long gdt表示的是我们GDT表的入口地址，然后我们可以看到上面便是gdt的定义。根据资料的查询我们可以知道，GDT全局描述符表由三个全局描述符组成，根据规定，第一个均为空描述符，第二个为代码段描述符，第三个为数据段描述符，所以在这里会相应的对应的三个内联汇编用来实现相应的操作，至此，我们的GDT表顺利加载完成。

接下来我们来继续观察对于寄存器CR0的操作：

一共包括了三个操作，首先将cr0寄存器里面的内容取出来，然后进行一个或操作，最后将得到的结果再写入cr0中，由上文我们知道，在这里需要将cr0的最低位设置为1，所以我们的或操作是用来使得cr0的最低位为1的操作，也就是说我们的CR0_PE_ON的值必须为1，这样才可以达成目的，然后通过查询CR0_PE_ON的定义我们发现的确为1，所以顺利开启PE位。

最后通过一个长跳转指令正式进入保护模式。

##### 练习4：分析bootloader加载ELF格式的OS的过程

