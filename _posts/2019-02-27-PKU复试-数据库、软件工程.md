---
layout:     post
title:      PKU复试-数据库、软件工程
subtitle:   北京大学复试面试准备资料😅
date:       2019-02-27
author:     IdiotLeo
header-img: img/beach_real_1.jpg
catalog: true
tags:
    - PKU
---

# 数据库

##### 什么是存储过程？有哪些优缺点？

存储过程就像我们编程语言中的函数一样，封装了我们的代码(PLSQL、T-SQL)。

存储过程的优点：

+ 能够将代码封装起来
+ 保存在数据库之中
+ 让编程语言进行调用
+ 存储过程是一个预编译的代码块，执行效率比较高
+ 一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率

存储过程的缺点：

+ 每个数据库的存储过程语法几乎都不一样，十分难以维护（不通用）
+ 业务逻辑放在数据库上，难以迭代

##### 三个范式是什么

+ 第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。
+ 第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。
+ 第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如果存在"A → B → C"的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段x → 非关键字段y

上面的文字我们肯定是看不懂的，也不愿意看下去的。接下来我就总结一下：

+ 首先要明确的是：满足着第三范式，那么就一定满足第二范式、满足着第二范式就一定满足第一范式

1.第一范式：字段是最小的的单元不可再分
+ 学生信息组成学生信息表，有年龄、性别、学号等信息组成。这些字段都不可再分，所以它是满足第一范式的

2.第二范式：满足第一范式,表中的字段必须完全依赖于全部主键而非部分主键。
+ 其他字段组成的这行记录和主键表示的是同一个东西，而主键是唯一的，它们只需要依赖于主键，也就成了唯一的
+ 学号为1024的同学，姓名为Java3y，年龄是22岁。姓名和年龄字段都依赖着学号主键。

3.第三范式：满足第二范式，非主键外的所有字段必须互不依赖
+ 就是数据只在一个地方存储，不重复出现在多张表中，可以认为就是消除传递依赖
+ 比如，我们大学分了很多系（中文系、英语系、计算机系……），这个系别管理表信息有以下字段组成：系编号，系主任，系简介，系架构。那我们能不能在学生信息表添加系编号，系主任，系简介，系架构字段呢？不行的，因为这样就冗余了，非主键外的字段形成了依赖关系(依赖到学生信息表了)！正确的做法是：学生表就只能增加一个系编号字段。

##### 什么是视图？以及视图的使用场景有哪些？

视图是一种基于数据表的一种**虚表**

+ （1）视图是一种虚表
+ （2）视图建立在已有表的基础上, 视图赖以建立的这些表称为基表
+ （3）向视图提供数据内容的语句为 SELECT 语句,可以将视图理解为存储起来的 SELECT 语句
+ （4）视图向用户提供基表数据的另一种表现形式
+ （5）视图没有存储真正的数据，真正的数据还是存储在基表中
+ （6）程序员虽然操作的是视图，但最终视图还会转成操作基表
+ （7）一个基表可以有0个或多个视图

有的时候，我们可能只关系一张数据表中的某些字段，而另外的一些人只关系同一张数据表的某些字段...

那么把全部的字段都都显示给他们看，这是不合理的。

我们应该做到：他们想看到什么样的数据，我们就给他们什么样的数据...一方面就能够让他们只关注自己的数据，另一方面，我们也保证数据表一些保密的数据不会泄露出来...

我们在查询数据的时候，常常需要编写非常长的SQL语句，几乎每次都要写很长很长....上面已经说了，视图就是基于查询的一种虚表，也就是说，视图可以将查询出来的数据进行封装。。。那么我们在使用的时候就会变得非常方便...

值得注意的是：使用视图可以让我们专注与逻辑，但不提高查询效率

##### 什么叫视图？游标是什么？

   视图是一种虚拟的表，通常是有一个表或者多个表的行或列的子集，具有和物理表相同的功能，可以对视图进行增，删，改，查等操作。特别地，对视图的修改不影响基本表。相比多表查询，它使得我们获取数据更容易。

   游标是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。

   在操作mysql的时候，我们知道MySQL检索操作返回一组称为结果集的行。这组返回的行都是与 SQL语句相匹配的行（零行或多行）。使用简单的 SELECT语句，例如，没有办法得到第一行、下一行或前 10行，也不存在每次一行地处理所有行的简单方法（相对于成批地处理它们）。有时，需要在检索出来的行中前进或后退一行或多行。这就是使用游标的原因。游标（cursor）是一个存储在MySQL服务器上的数据库查询，它不是一条 SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。

##### 什么是触发器？

　　触发器是与表相关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用在数据库端确保数据库的完整性。

##### drop、delete与truncate分别在什么场景之下使用？

+ 不再需要一张表的时候，用drop
+ 想删除部分数据行时候，用delete，并且带上where子句
+ 保留表而删除所有数据的时候用truncate

##### 数据库索引

   索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B_TREE及其变种。索引加速了数据访问，因为存储引擎不会再去扫描整张表得到需要的数据；相反，它从根节点开始，根节点保存了子节点的指针，存储引擎会根据指针快速寻找数据。
   
**索引的底层实现原理和优化**

   在数据结构中，我们最为常见的搜索结构就是二叉搜索树和AVL树(高度平衡的二叉搜索树，为了提高二叉搜索树的效率，减少树的平均搜索长度)了。然而，无论二叉搜索树还是AVL树，当数据量比较大时，都会由于树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下，因此对于索引而言，多叉树结构成为不二选择。特别地，B-Tree的各种操作能使B树保持较低的高度，从而保证高效的查找效率。
  
**1.B-Tree(平衡多路查找树)**

　　B_TREE是一种平衡多路查找树，是一种动态查找效率很高的树形结构。B_TREE中所有结点的孩子结点的最大值称为B_TREE的阶，B_TREE的阶通常用m表示，简称为m叉树。一般来说，应该是m>=3。一颗m阶的B_TREE或是一颗空树，或者是满足下列条件的m叉树：

+ 树中每个结点最多有m个孩子结点；
+ 若根结点不是叶子节点，则根结点至少有2个孩子结点；
+ 除根结点外，其它结点至少有(m/2的上界)个孩子结点；
+ 结点的结构如下图所示，其中，n为结点中关键字个数，(m/2的上界)-1 <= n <= m-1；di(1<=i<=n)为该结点的n个关键字值的第i个，且di< d(i+1)；ci(0<=i<=n)为该结点孩子结点的指针，且ci所指向的节点的关键字均大于或等于di且小于d(i+1)；

![](https://i.loli.net/2019/02/27/5c761ba488852.png)

+ 所有的叶结点都在同一层上，并且不带信息（可以看作是外部结点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空）。

   下图是一棵4阶B_TREE，4叉树结点的孩子结点的个数范围[2,4]。其中，有2个结点有4个孩子结点，有1个结点有3个孩子结点，有5个结点有2个孩子结点。
   
![](https://i.loli.net/2019/02/27/5c761c76ecf10.jpg)

   B_TREE的查找类似二叉排序树的查找，所不同的是B-树每个结点上是多关键码的有序表，在到达某个结点时，先在有序表中查找，若找到，则查找成功；否则，到按照对应的指针信息指向的子树中去查找，当到达叶子结点时，则说明树中没有对应的关键码。由于B_TREE的高检索效率，B-树主要应用在文件系统和数据库中，对于存储在硬盘上的大型数据库文件，可以极大程度减少访问硬盘次数，大幅度提高数据检索效率。

**2.B+Tree ： InnoDB存储引擎的索引实现**

   B+Tree是应文件系统所需而产生的一种B_TREE树的变形树。一棵m阶的B+树和m阶的B_TREE的差异在于以下三点：

+ n 棵子树的结点中含有n个关键码；
+ 所有的叶子结点中包含了全部关键码的信息，及指向含有这些关键码记录的指针，且叶子结点本身依关键码的大小自小而大的顺序链接；
+ 非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键码。

   下图为一棵3阶的B+树。通常在B+树上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点。因此可以对B+树进行两种查找运算：一种是从最小关键字起顺序查找，另一种是从根节点开始，进行随机查找。 

   在B+树上进行随机查找、插入和删除的过程基本上与B-树类似。只是在查找时，若非终端结点上的关键码等于给定值，并不终止，而是继续向下直到叶子结点。**因此，对于B+树，不管查找成功与否，每次查找都是走了一条从根到叶子结点的路径。**

![](https://i.loli.net/2019/02/27/5c761e30ca3e3.jpg)

**为什么说B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引？**

+ B+tree的磁盘读写代价更低：B+tree的内部结点并没有指向关键字具体信息的指针(红色部分)，因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了；
+ B+tree的查询效率更加稳定：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；
+ 数据库索引采用B+树而不是B树的主要原因：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。

**文件索引和数据库索引为什么使用B+树?**

   文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。最重要的是，B+树还有一个最大的好处：方便扫库。B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。

**索引的优点**

+ 大大加快数据的检索速度，这也是创建索引的最主要的原因；
+ 加速表和表之间的连接；
+ 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；
+ 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；

**索引的缺点**

+ 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；
+ 空间方面：索引需要占物理空间。

**索引的分类**

+ 唯一索引：唯一索引不允许两行具有相同的索引值
+ 主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空
+ 聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个
+ 非聚集索引(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个

**主键、自增主键、主键索引与唯一索引概念区别**

+ **主键**：指字段 唯一、不为空值 的列；
+ **主键索引**：指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键的时候，数据库默认会为主键创建一个唯一索引；
+ **自增主键**：字段类型为数字、自增、并且是主键；
+ **唯一索引**：索引列的值必须唯一，但允许有空值。主键是唯一索引，这样说没错；但反过来说，唯一索引也是主键就错误了，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。(区别)

##### 什么是事务？

事务简单来说：**一个Session中所进行所有的操作，要么同时成功，要么同时失败**

**ACID — 数据库事务正确执行的四个基本要素**

+ 包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。

一个支持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易。

+ 脏读：一个事务读取到另外一个事务未提交的数据

   例子：A向B转账，A执行了转账语句，但A还没有提交事务，B读取数据，发现自己账户钱变多了！B跟A说，我已经收到钱了。A回滚事务【rollback】，等B再查看账户的钱时，发现钱并没有多。

+ 不可重复读：一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改

   注：A查询数据库得到数据，B去修改数据库的数据，导致A多次查询数据库的结果都不一样【危害：A每次查询的结果都是受B的影响的，那么A查询出来的信息就没有意思了】
   
+ 虚读(幻读)：是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。

   注：和不可重复读类似，但虚读(幻读)会读到其他事务的插入的数据，导致前后读取不一致
   
**简单总结：脏读是不可容忍的，不可重复读和虚读在一定的情况下是可以的【做统计的肯定就不行】。**

##### 超键、候选键、主键、外键分别是什么？

+ 超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
+ 候选键(候选码)：是最小超键，即没有冗余元素的超键。
+ 主键(主码)：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。
+ 外键：在一个表中存在的另一个表的主键称此表的外键。

**候选码和主码：**

例子：邮寄地址（城市名，街道名，邮政编码，单位名，收件人）

+ 它有两个候选键:{城市名，街道名} 和 {街道名，邮政编码}
+ 如果我选取{城市名，街道名}作为唯一标识实体的属性，那么{城市名，街道名} 就是主码(主键)


# 软件工程

##### 什么是软件工程?它目标和内容是什么?

+ 软件工程就是用科学的知识和技术原理来定义，开发，维护软件的一门学科。
+ 软件工程目标：付出较低开发成本；达到要求的功能；取得较好的性能；开发的软件易于移植；只需较低的维护费用；能按时完成开发任务，及时交付使用；开发的软件可靠性高。
+ 软件工程内容：包括开发技术和开发管理两个方面。

##### 软件开发中有哪几种过程模型?哪些适用于面向对象的软件开发?

软件开发中常见的软件过程模型有瀑布模型、原型模型、螺旋模型、喷泉模型、统一软件过程等。

其中喷泉模型、统一软件过程适用于面向对象的软件开发。

##### 什么是结构分析方法?该方法使用什么描述工具?

结构化分析：简称SA，面向数据流进行数据分析的方法。采用自顶向下逐层分解的分析策略。顶层抽象地描述整个系统，底层具体地画出系统工程的每个细节。中间层则是从抽象到具体的过渡。使用数据流图，数据字典，作为描述工具，使用结构化语言，判定表，判定树描述加工逻辑。

##### 什么是软件概要设计?该阶段的基本任务是什么?
把一个软件需求转换为软件表示时，首先设计出软件总的体系结构。称为概要设计或结构设计。

基本任务：

+ ⑴设计软件系统结构
+ ⑵进行数据结构及数据库的设计
+ ⑶编写概要设计的文档
+ ⑷评审

##### 软件维护有哪些内容?

+ （1）校正性维护。在软件交付使用后，一些隐含的错误在某些特定的使用环境下会暴露出来。为了识别和纠正错误，修改软件性能上的缺陷，应进行确定和修改错误的过程，这个过程就称为校正性维护。
+ （2）适应性维护。为了使应用软件适应计算机硬件、软件环境及数据环境的不断发生的变化而修改软件的过程称为适应性维护。
+ （3）完善性维护。为增加软件功能、增强软件性能、提高软件运行效率而进行的维护活动称为完善性维护。
+ （4）预防性维护。为了提高软件的可维护性和可靠性而对软件进行的修改称为预防性维护。

##### 软件测试要经过哪些步骤?这些测试与软件开发各阶段之间有什么关系?

软件测试要经过的步骤是：单元测试→集成测试→确认测试→系统测试。

+ 单元测试对源程序中每一个程序单元进行测试，检查各个模块是否正确实现规定的功能，从而发现模块在编码中或算法中的错误。该阶段涉及编码和详细设计文档。
+ 集成测试是为了检查与设计相关的软件体系结构的有关问题，也就是检查概要设计是否合理有效。
+ 确认测试主要是检查已实现的软件是否满足需求规格说明书中确定了的各种需求。
+ 系统测试是把已确认的软件与其他系统元素(如硬件、其他支持软件、数据、人工等)结合在一起进行测试。以确定软件是否可以支付使用。

##### 什么是软件生存周期?它有哪几个活动?

软件生存周期：一个软件从提出开发要求开始直到该软件报废为止的整个时期。

包括：问题定义，可行性分析和项目开发计划，需求分析，概要设计，详细设计，编码，测试，维护。

##### 什么是需求分析?需求分析阶段的基本任务是什么?

需求分析：开发人员准确地理解用户的要求，进行细致的调查分析，将用户非形式的需求陈述转化为完整的需求定义，再由需求定义转换到相应的需求规格说明的过程。

基本任务：

+ ⑴问题识别
+ ⑵分析与综合，导出软件的逻辑模型
+ ⑶编写文档

##### 软件工程三要素

软件工程包括三个要素：方法、工具和过程。

+ 软件工程方法为软件开发提供了“如何做”的技术。
+ 软件工具为软件工程方法提供了自动的或半自动的软件支撑环境。
+ 软件工程的过程则是将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的。过程定义了方法使用的顺序、要求交付的文档资料、为保证质量和协调变化所需要的管理、及软件开发各个阶段完成的里程碑。
