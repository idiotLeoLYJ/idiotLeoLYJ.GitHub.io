---
layout:     post
title:      DS-学习笔记
subtitle:   数据结构（C++语言版）
date:       2018-07-31
author:     IdiotLeo
header-img: img/beach_real_2.jpg
catalog: true
tags:
    - 数据结构
    - DS
---

# Overview

记录学习数据结构的知识结构

# 第三章 列表

##### 3.1 从向量到列表


[**列表**] 结构尽管也要求各元素在逻辑上具有线性次序，但对其物理地址却未做任何限制——几位“动态存储”策略。

##### 3.2 接口


[**节点内部**] T data; ListNode(T) pred; ListNode(T) succ;

##### 3.3 列表


[**头、尾节点**] 私有的头节点（header）和尾节点（trailer）始终存在，对外不可见。对外部可见的节点如果存在则第一个和最后一个称为首节点（first node）和末节点（last node）

外部不可见的节点叫做哨兵节点。

[**秩到位置的转换**] 重载操作符“[]”。

[**查找**] 时间复杂度O(n)，线性正比于查找区间的宽度。

[**插入**] 具有特定的操作顺序（顺序不可颠倒）。

[**删除**] 具有特定的操作顺序（顺序不可颠倒）。

[**析构**] 反复删除首节点。

[**唯一化**] 需要O（n）步迭代，每次迭代中find（）操作所需的时间线性正比于查找区间宽度，即当前节点的秩。

时间复杂度：1 + 2 + 3 + ···· + n = O（n^2）

##### 3.4 有序列表


大小次序与逻辑次序完全一致。

[**唯一化**] 两个指针p q分别指向每一对相邻的节点。时间复杂度：O（n）。

[**查找**] 顺序查找。原因：在动态存储策略中，节点的物理地址与逻辑次序毫无关系，故无法像有序向量那样自如地应用减而治之。

##### 3.5 排序器


[**插入排序**] 特点：在任何时刻，前缀总是已经有序。不断地插入。时间复杂度（取决于每一步的查找、删除、插入操作）：O（n^2）。

[**选择排序**] 特点：任何时刻，后缀总是已经有序。在前缀中找最大的插入后缀首节点。时间复杂度：O（n^2）。

[**归并排序**] 归并时间复杂度：O（m + n）。分治时间复杂度O（logn）。总时间复杂度：O（nlogn）。






