---
layout:     post
title:      PKU复试-专业课知识
subtitle:   北京大学复试面试准备资料😅
date:       2019-02-25
author:     IdiotLeo
header-img: img/beach_real_1.jpg
catalog: true
tags:
    - PKU
---

# C++

### 基础知识

##### 有符号类型和无符号类型

+ 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模之后的余数。当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的；此时，程序可能继续工作、可能崩溃。也可能生成垃圾数据。
+ 如果表达式中既有带符号类型由于无符号类型那个，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动转换成无符号数。

##### 什么是“引用”？申明和使用“引用”要注意哪些问题？

引用就是某个目标变量的“别名”(alias)，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。

##### 将“引用”作为函数参数有哪些特点？

1.传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。
2.使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。
3.使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"\*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。

##### 引用与指针

+ 引用并非对象，它只是为一个已经存在的对象起的一个别名。在定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。一旦初始化完成，应用将和它的初始值绑定在一起。以为无法令引用重新绑定到另外一个对象，因此引用必须初始化。
+ 指针是指向另外一种类型的符合类型。与引用类似，指针也实现了对其他对象的简介访问。然而指针与引用相比又有许多不同点：
1.指针本身就是一个对象，允许对指针赋值和拷贝。而且在指针的生命周期内它可以先后指向几个不同的对象。引用不是对象，所以也不能定义指向引用的指针。
2.指针无须在定义时赋值。

+ 引用必须被初始化，指针不必。
+ 引用初始化以后不能被改变，指针可以改变所指的对象。
+ 不存在指向空值的引用，但是存在指向空值的指针。

##### static关键字

+ 申明为static的局部变量，存储在静态存储区，其生存期不再局限于当前作用域，而是整个程序的生存期。
+ 对于全局变量而言， 普通的全局变量和函数，其作用域为整个程序或项目，外部文件（其它cpp文件）可以通过extern关键字访问该变量和函数；static全局变量和函数，其作用域为当前cpp文件，其它的cpp文件不能访问该变量和函数。

##### const限定符

+ 在定义常变量时必须同时对它初始化，此后它的值不能再改变。常变量不能出现在赋值号的左边（不为“左值”）；
+ 用const修饰的符号常量的区别：const位于（\*）的左边，表示被指物是常量；const位于(\*)的右边，表示指针自身是常量（常量指针）。（口诀：左定值，右定向）

##### const与#define的区别

+ const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。
+ const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。
+ 在C++程序中只使用const常量而不使用宏常量，即const常量完全取代宏常量。

##### 数组与指针的区别

+ 数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。
+ 用运算符sizeof可以计算出数组的容量（字节数）。sizeof(p)，p为指针得到的是一个指针变量的字节数，而不是p所指的内存容量。C/C++语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。
+ C++编译系统将形参数组名一律作为指针变量来处理。实际上在函数调用时并不存在一个占有存储空间的形参数组，只有指针变量。

##### sizeof运算符

sizeof是C语言的一种单目操作符，它并不是函数。操作数可以是一个表达式或类型名。数据类型必须用括号括住，sizeof（int）;变量名可以不用括号括住。
```
int a[50];  //sizeof(a)=200
int *a=new int[50];  //sizeof(a)=4;
Class Test{int a; static double c};  //sizeof(Test)=4
Test *s;  //sizeof(s)=4
Class Test{ };  //sizeof(Test)=1
int func(char s[5]);  //sizeof(s)=4;
```
操作数不同时注意事项：
+ 数组类型，其结果是数组的总字节数；指向数组的指针，其结果是该指针的字节数。
+ 函数中的数组形参或函数类型的形参，其结果是指针的字节数。
+ 联合类型，其结果采用成员最大长度对齐。
+ 结构类型或类类型，其结果是这种类型对象的总字节数，包括任何填充在内。

例题：

1.下列联合体的sizeof(sampleUnion)的值为多少。
```
union{
    char flag[3];
    short value;
} sampleUnion;
```
答案：4。联合体占用大小采用成员最大长度的对齐，最大长度是short的2字节。但char flag[3]需要3个字节，所以sizeof(sampleUnion) = 2\*（2字节）= 4。注意对齐有两层含义，一个是按本身的字节大小数对齐，一个是整体按照最大的字节数对齐。

2.在32位系统中：
```
char arr[] = {4, 3, 9, 9, 2, 0, 1, 5};
char *str = arr;
sizeof(arr) = 8;
sizeof(str) = 4;
strlen(str) = 5;
```
答案：8，4，5。注意strlen函数求取字符串长度以ASCII值为0为止。

3.定义一个空的类型，里面没有任何成员变量和成员函数。
+ 问题：对该类型求sizeof，得到的结果是什么？
答案：1。
+ 问题：为什么不是0？
答案：当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。至于占用多少内存，由编译器决定。Visual Studio中每个空类型的实例占用1字节的空间。
+ 问题：如果在该类型中添加一个构造函数和析构函数，结果又是什么？
答案：还是1。调用构造函数和析构函数只需要知道函数的地址即可，而这些函数的地址只与类型相关，而与类型的实例无关。
+ 问题：那如果把析构函数标记为虚函数呢？
答案：C++的编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针。在32位的机器上，指针占用4字节，因此求sizeof得到4；如果是64位机器，将得到8。

##### 结构与联合有和区别？

1.结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。 
2.对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。

##### malloc/free 与 new/delete的区别

+ malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请和释放动态内存。
+ 对于非内部数据类型的对象而言，用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free，因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，和一个能完成清理与释放内存工作的运算符delete。
+ new可以认为是malloc加构造函数的执行。new出来的指针是直接带类型信息的。而malloc返回的都是void\*指针。newdelete在实现上其实调用了malloc,free函数。
+ new建立的是一个对象；malloc分配的是一块内存。

##### delete与 delete []区别

delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。在More Effective C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operator delete来释放内存。”delete与new配套，delete \[]与new \[]配套

##### 子类析构时要调用父类的析构函数吗？

析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了。定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。

##### 多态，虚函数，纯虚函数

+ 多态：是对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：在程序运行时的多态性通过继承和虚函数来体现；在程序编译时多态性体现在函数和运算符的重载上；

+ 虚函数：在基类中冠以关键字 virtual 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。

+ 纯虚函数的作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在 纯虚函数不具备函数的功能，一般不能直接被调用。从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）。抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。

##### 重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？

常考的题目。从定义上来说：

+ 重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。
+ 重写：是指子类重新定义父类虚函数的方法。

从实现原理上来说：

+ 重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！
+ 重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。

##### C++是不是类型安全的？

不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。

##### main 函数执行以前，还会执行什么代码？

全局对象的构造函数会在main 函数之前执行。

##### int (\*s\[10])(int) 表示的是什么？

int (\*s\[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。

##### 基类的析构函数不是虚函数，会带来什么问题？

派生类的析构函数用不上，会造成资源的泄漏。

##### 全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？

1.生命周期不同：

全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；

2.使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。 

操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。

### 面向对象编程

##### 派生类中构造函数与析构函数，调用顺序

构造函数的调用顺序总是如下：

1.基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。
2.成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。如果有的成员不是类对象，而是基本类型，则初始化顺序按照声明的顺序来确定，而不是在初始化列表中的顺序。
3.派生类构造函数。

析构函数正好和构造函数相反。

##### 虚函数
这种函数或方法可以被子类继承和覆盖，通常使用动态调度实现。这一概念是面向对象程序设计中（运行时）多态的重要组成部分。简言之，虚函数可以给出目标函数的定义，但该目标的具体指向在编译期可能无法确定。


